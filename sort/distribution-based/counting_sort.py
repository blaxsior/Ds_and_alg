"""
일정한 범위 내의 값만으로 배열이 구성될 때 사용한다.
1. 각 원소의 갯수를 세서 대응되는 배열에 갯수 적어놓기
2. 갯수가 적힌 배열을 누적 형태로 바꿈 -> 이전 행의 값 더하기
3. 데이터 배열의 뒤에서부터 하나씩 숫자를 읽어 / 해당 값에 대응되는 갯수 적힌 배열 값에 해당하는 인덱스 위치에 넣음.
4. 값을 인덱스 위치에 넣은 후, 갯수 배열에 적힌 숫자를 1 감소시킨다.

현재 예시에서는 0~5 범위에 대해서 counting sort를 진행한다.
만약 여러 범위를 커버해야 한다면 가질 수 있는 값을 배열로 입력받고, set 자료구조에 값을 넣어두는 등 가능.

stop = 5 이면, 배열의 길이는 6.
여기서는 0 ~ n 숫자에 대한 계수 정렬을 나타낸다.
"""
def counting_sort(arr: list[int], stop: int):
    idx = [0 for _ in range(stop + 1)] # 특정 값이 등장한 횟수를 지정하는 배열
    result = [0 for _ in range(len(arr))] # 정렬된 결과가 저장되는 배열.
    # 갯수 세는 배열 초기화
    for i in arr :
        idx[i] += 1 # 배열 요소들에 대응되는 갯수 기록

    for i in range(1, len(idx)): # 누적 합 형태로 카운트 변경
        idx[i] += idx[i - 1]

    for i in range(len(idx)) :
        if idx[i] > 0 :
            idx[i] -= 1 # 인덱스를 맞춰주기 위해 1씩 값을 감소시킨다.

    arr.reverse() # 뒤에서부터 값을 하나씩 빼면서 특정 위치에 저장한다.
                    # 해당 동작을 위한 배열 뒤집기.

    for val in arr :
        result[idx[val]] = val
        idx[val] -= 1
    
    return result

arr = [5,3,4,1,5,4,1,4]
arr = counting_sort(arr,5)
print(arr)

# 시간 복잡도 : O(n + k) -> O(n)
# 제자리성 : 입력 크기에 비례하는 배열이 필요하므로, 제자리성 없음
# 안정성 : 배열의 뒤 값부터 순서대로 배치하므로, 순서 변경 없어 안정적임.